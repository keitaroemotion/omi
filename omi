#!/usr/bin/env ruby

#
# YOU NEED TO USE API_CALLER SUCH AS:
#
# ./api_caller scripts/[your script you want]
#
#
# XXX might need Turing Incomplete features 
#     such that enables executing the script files
#     consecutively the former script passes the
#     output to the latter.
#
# XXX might need to make this application installable  


#
# XXX omi card destroy => authentication failure
#

require "colorize"

APIS = %w(card charge customer dispute refund token edit)
RESOURCES   = "/usr/local/etc/omi"
SCRIPTS     = "#{RESOURCES}/scripts"
CONFIG_PATH = "#{RESOURCES}/config"

def help(key=nil)
    key = ARGV[1] unless key
    if key == "apis"
        puts
        APIS.each {|a| puts a}
        puts
        abort
    end
    list = [
        "omi [card    ] destroy   ... destroy a card",
        "omi [card    ] list      ... list_all_cards",
        "omi [card    ] get       ... retrieve_a_card",
        "omi [card    ] update    ... update_a_card",
        "omi [charge  ] list      ... list all charges",
        "omi [charge  ] update    ... update_a_charge" ,
        "omi [charge  ] reverse   ... reverse_an_uncaptured_charge",
        "omi [charge  ] get       ... retrieve_a_charge",
        "omi [charge  ] coib      ... create_an_offsite_internet_banking_charge",
        "omi [charge  ] coa       ... create_an_offsite_alipay_charge",
        "omi [charge  ] wt        ... charge_a_card_using_a_token",
        "omi [charge  ] wcc       ... charge_a_card_using_a_customer_and_a_card",
        "omi [charge  ] wc        ... charge_a_card_using_a_customer",
        "omi [charge  ] capture   ... capture_an_authorized_charge",
        "omi [customer] destroy   ... destory a customer", 
        "omi [customer] create_wc ... create_a_customer_and_attach_a_card",
        "omi [customer] create    ... create_a_customer",
        "omi [customer] add_card  ... attach_a_card_to_customer",
        "omi [customer] list      ... list_all_customers",
        "omi [customer] get       ... retrieve_a_customer",
        "omi [customer] update    ... update_a_customer",
        "omi [dispute ] list      ... list_all_disputes",
        "omi [dispute ] lao       ... list_all_open_disputes",
        "omi [dispute ] lap       ... list_all_pending_disputes",
        "omi [dispute ] lac       ... list_all_closed_disputes",
        "omi [dispute ] get       ... retrieve_a_dispute",
        "omi [dispute ] update    ... update_a_dispute",
        "omi [refund  ] create    ... create_a_refund",
        "omi [refund  ] list      ... list_all_refunds",
        "omi [refund  ] lap       ... list_all_refunds_of_particular_charge",
        "omi [refund  ] get       ... retrieve_a_refund",
        "omi [token   ] create    ... create a token", 
        "omi [token   ] get       ... retrieve a token", 
        "omi [edit    ] [api_name] [key_word]",
    ]
    if key
      list = list.select{|x| x.include?("omi [#{key}") }
    end
    puts
    puts "option: -e allows editing the command before execution"
    puts "option: -v allows viewing the execution result"
    list.each {|x| puts x}
    puts
    abort
end

if %w(help --h -h).include?(ARGV[0])
    help
end
HAS_EQUAL   = /^.+\=.+$/

def get_options
    list = ARGV
        .select { |a| a =~ HAS_EQUAL           }
        .map    { |a| a.split('=').map(&:to_s) }
        .flatten
    Hash[*list]  
end

def vim?
    ARGV.include?("--vim") || ARGV.include?("-v")
end

options = get_options

abort "config file missing" unless File.exist?(CONFIG_PATH)

def config
    lines = File
        .open(CONFIG_PATH, "r")
        .each_line
        .to_a
        .select { |a| a =~ HAS_EQUAL } 
    lines.map{ |line| line.split("=").map(&:chomp) }.flatten
end

config_hash = Hash[*(config)]
skey        = config_hash["skey"]
pkey        = config_hash["pkey"]

def args
    ARGV.select {|a| /^[^\=]+$/ =~ a  && !APIS.include?(a) }
end

def options
    ARGV.select {|a| /^.+[\=]+.+$/ =~ a }
end

def api 
    api = ARGV.select {|a| APIS.include?(a.strip) }
    unless api.size > 0
        abort("\napi missing. please input any of the following:  \n\n#{APIS}\n\n")
    end
    api.first
end

def translate_customer
    {
        destroy:   "destroy_a_customer",
        create_wc: "create_a_customer_and_attach_a_card",
        create:    "create_a_customer",
        add_card:  "attach_a_card_to_customer",
        list:      "list_all_customers",
        list_all:  "list_all_customers",
        get:       "retrieve_a_customer",
        update:    "update_a_customer",
    }
end

def translate_token
    {
        create: "create_a_token", 
        get:    "retrieve_a_token",
    }
end

def translate_card
    {
        destroy:  "destroy_a_card",
        list:     "list_all_cards",
        list_all: "list_all_cards",
        get:      "retrieve_a_card",
        update:   "update_a_card",
    }
end

def translate_charge
    {
        list:     "list_all_charges",
        list_all: "list_all_charges",
        update:   "update_a_charge", 
        reverse:  "reverse_an_uncaptured_charge",
        get:      "retrieve_a_charge",
        coib:     "create_an_offsite_internet_banking_charge",
        coa:      "create_an_offsite_alipay_charge",
        wt:       "charge_a_card_using_a_token",
        wcc:      "charge_a_card_using_a_customer_and_a_card",
        wc:       "charge_a_card_using_a_customer",
        capture:  "capture_an_authorized_charge",
    }
end

def translate_dispute
    {
        list:     "list_all_disputes",
        list_all: "list_all_disputes",
        lao:      "list_all_open_disputes",
        lap:      "list_all_pending_disputes",
        lac:      "list_all_closed_disputes",
        get:      "retrieve_a_dispute",
        update:   "update_a_dispute",
    }
end

def translate_refund
    {
        list:     "list_all_refunds",
        list_all: "list_all_refunds",
        lap:      "list_all_refunds_of_particular_charge",
        get:      "retrieve_a_refund",
        create:   "create_a_refund",
    }
end

def translate(api, key)
    api_translation = {
        charge:   translate_charge,
        card:     translate_card,
        customer: translate_customer,
        token:    translate_token,
        dispute:  translate_dispute,
        refund:   translate_refund,
    }[api.to_sym]
    abort "api missing" unless api_translation 
    result = api_translation[(key || "").to_sym]
    help(api) unless result
    result
end

def get_script_path(key)
    "#{SCRIPTS}/#{api}/#{translate(api, key)}"
end

script_path = get_script_path(args.first)
script_body = File.read(script_path).gsub("$skey", skey).gsub("$pkey", pkey)

def gsub(key, script_body, options, config)
    if script_body.include?("$#{key}")
        if options[key]
            script_body = script_body.gsub("$#{key}", options[key])  
        elsif config[key]    
            script_body = script_body.gsub("$#{key}", config[key])  
        else
            abort "You need argument #{key}="
        end
    end
    script_body
end        

def list_values_and_gsub(script_body, skey, api, prefix, options, value="")
    if script_body.include?("$#{api}") 
       puts
       cmd = "curl -s -X GET https://api.omise.co/#{api}s -u #{skey}:"
       if api == "card"
           puts api
           cmd = "curl -s -X GET https://api.omise.co/customers/#{value}/cards"
       end
       puts cmd.cyan
       result = `#{cmd}`
       list = result
                  .split("\n")
                  .select { |a| a.include?(prefix) }
                  .map    { |a| /#{prefix}[a-z0-9_]+/.match(a).to_s.strip }
                  .uniq
       if api == "customer" && options["customer"]
           value = options["customer"]
       else
           if list.size == 0
               puts result
           else  
               list.each_with_index { |e, i| puts "[#{i}] #{e}" }
               print "\n[which?] "    
               value = list[$stdin.gets.chomp.to_i]
           end
       end    
       script_body = script_body.gsub("$#{api}", value)
    end
    [script_body, value]
end

#
# XXX need this to be refactored as iteration
#
script_body = gsub("charge", script_body, options, config_hash)
script_body = gsub("token", script_body, options, config_hash)
script_body = gsub("dispute", script_body, options, config_hash)
script_body = gsub("amount", script_body, options, config_hash)
script_body, value = list_values_and_gsub(script_body, skey, "customer", "cust_", options)
script_body, value = list_values_and_gsub(script_body, skey, "charge", "chrg_", options, value)
script_body, value = list_values_and_gsub(script_body, skey, "card", "card_", options, value)

unless script_path.include?("curl -s")
    script_body = script_body.gsub("curl", "curl -s")
end

def pre_edit?
  ARGV.include?("-e")
end

if pre_edit?
   tmp = ".tmp_file_omise"
   File.open(tmp, "w") { |f| f.puts script_body }
   system("vim #{tmp}")
   script_body = File.read(tmp)
   system("rm #{tmp}")
end

command = script_body.lines.select { |line| !(line.start_with?("#")) }.join.chomp

if vim?
   result           = `#{script_body}`
   sentence         = "#{command.strip}\n\n#{result}"
   result_file_name = "curl_result.tmp"
   File.open(result_file_name, "w") do |f|
       f.puts sentence
   end
   system "vim #{result_file_name}"
else
    puts "-------------------------"
    puts "[Command]\n"
    puts command.green
    puts "-------------------------"

    shell_execution_result = `#{script_body}`
    puts shell_execution_result

    if File.basename(script_path) == "create_a_token"
        token = shell_execution_result
            .split("\n")
            .select{ |a| a.include?("tokn_")             }
            .map   { |a| /tokn_[a-z0-9_]+/.match(a).to_s }
            .flatten
            .uniq
        `echo token=#{token.first} | pbcopy`    
    end
end    
