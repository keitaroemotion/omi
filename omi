#!/usr/bin/env ruby

require "colorize"

APIS        = %w(card charge customer dispute refund token recipient transfer)
APIS_PLURAL = %w(cards charges customers disputes refunds tokens recipients transfers)
RESOURCES   = "/usr/local/etc/omi"
SCRIPTS     = "#{RESOURCES}/scripts"
CONFIG_PATH = "#{RESOURCES}/config"

def psp
    psps = %w(omise stripe)
    @argv.each do |a|
        if psps.include?(a)
            return a
        end
    end
    "omise"
end

@argv = ARGV.map { |a| APIS_PLURAL.include?(a) ? [a[0...-1], "list"] : a }.flatten
@psp = psp

def help(key=nil)
    key = @argv[1] unless key
    if key == "apis"
        puts
        APIS.each {|a| puts a}
        puts
        abort
    end
    list = [
        "omi [card    ]  delete    ... delete a card",
        "omi [card    ]  list      ... list_all_cards",
        "omi [cards   ]            ... list_all_cards",
        "omi [card    ]  get       ... retrieve_a_card",
        "omi [card    ]  update    ... update_a_card",
        "omi [charge  ]  list      ... list all charges",
        "omi [charges ]            ... list all charges",
        "omi [charge  ]  update    ... update_a_charge" ,
        "omi [charge  ]  reverse   ... reverse_an_uncaptured_charge",
        "omi [charge  ]  get       ... retrieve_a_charge",
        "omi [charge  ]  coib      ... create_an_offsite_internet_banking_charge",
        "omi [charge  ]  coa       ... create_an_offsite_alipay_charge",
        "omi [charge  ]  wt        ... charge_a_card_using_a_token",
        "omi [charge  ]  wcc       ... charge_a_card_using_a_customer_and_a_card",
        "omi [charge  ]  wc        ... charge_a_card_using_a_customer",
        "omi [charge  ]  capture   ... capture_an_authorized_charge",
        "omi [customer]  delete    ... delete a customer", 
        "omi [customer]  create_wc ... create_a_customer_and_attach_a_card",
        "omi [customer]  create    ... create_a_customer",
        "omi [customer]  add_card  ... attach_a_card_to_customer",
        "omi [customer]  list      ... list_all_customers",
        "omi [customers]           ... list_all_customers",
        "omi [customer]  get       ... retrieve_a_customer",
        "omi [customer]  update    ... update_a_customer",
        "omi [disputes]            ... list_all_disputes",
        "omi [dispute ]  lao       ... list_all_open_disputes",
        "omi [dispute ]  lap       ... list_all_pending_disputes",
        "omi [dispute ]  lac       ... list_all_closed_disputes",
        "omi [dispute ]  get       ... retrieve_a_dispute",
        "omi [dispute ]  update    ... update_a_dispute",
        "omi [recipient] list      ... list_all_recipient",
        "omi [recipients]          ... list_all_recipient",
        "omi [recipient] create    ... create_a_recipient",
        "omi [recipient] get       ... retrieve_a_recipient",
        "omi [recipient] update    ... update_a_recipient",
        "omi [recipient] delete    ... delete_a_recipient" ,
        "omi [refund  ] create    ... create_a_refund",
        "omi [refund  ] list      ... list_all_refunds",
        "omi [refunds ]           ... list_all_refunds",
        "omi [refund  ] lap       ... list_all_refunds_of_particular_charge",
        "omi [refund  ] get       ... retrieve_a_refund",
        "omi [token   ] create    ... create a token", 
        "omi [token   ] get       ... retrieve a token", 
        "omi [transfer] create    ... create_a_transfer",
        "omi [transfer] cr3       ... create_a_transfer_to_third_party_recipient",
        "omi [transfer] delete    ... delete_a_transfer",
        "omi [transfer] list      ... list_all_transfers",
        "omi [transfers]          ... list_all_transfers",
        "omi [transfer] get       ... retrieve_a_transfer",
        "omi [transfer] update    ... update_a_transfer",
        "omi [edit    ] [api_name] [key_word]",
    ]
    if key
        list = list.select{|x| x.include?("omi [#{key}") }
    end
    puts
    list.each {|x| puts x}
    puts "[option: -d dry_run]"
    puts "[option: -e allows editing the command before execution]"
    puts "[option: -v allows viewing the execution result]"
    puts "[option: -l swaps URL into localhost]"
    puts
    abort
end

if %w(help --h -h).include?(@argv[0])
    help
end
HAS_EQUAL   = /^.+\=.+$/

def get_options
    list = @argv
        .select { |a| a =~ HAS_EQUAL           }
        .map    { |a| a.split('=').map(&:to_s) }
        .flatten
    Hash[*list]  
end

def vim?
    @argv.include?("--vim") || @argv.include?("-v")
end

options = get_options

abort "config file missing" unless File.exist?(CONFIG_PATH)

def config
    lines = File
        .open(CONFIG_PATH, "r")
        .each_line
        .to_a
        .select { |a| a =~ HAS_EQUAL } 
    lines.map{ |line| line.split("=").map(&:chomp) }.flatten
end

def automate_key(keys, sym)
    /[^\:]$/ =~ keys[sym] ? keys[sym] + ":" : keys[sym]
end

def get_keys
    keys = @argv.select {|a| /[ps]key_[\d\w\_\:]+/ =~ a }
    if keys.size > 0
        return {
            pkey: (keys.select{|a| /pkey/ =~ a }.first.to_s.strip.chomp),
            skey: (keys.select{|a| /skey/ =~ a }.first.to_s.strip.chomp)
        }  
    end
end

config_hash = Hash[*(config)]
skey        = config_hash["skey"]
pkey        = config_hash["pkey"]

keys = get_keys || {pkey: "", skey: ""}

def fill_key(keys, sym, key)
    if keys[sym] != "" 
        key = automate_key(keys, sym)
        puts "key substitution: #{key}"
    end
    key
end

#
# if there are skey_ or pkey_ incoming arguments,
# let it override the config_hash
#
pkey = fill_key(keys, :pkey, pkey)
skey = fill_key(keys, :skey, skey)

def args
    @argv.select {|a| /^[^\=]+$/ =~ a  && !APIS.include?(a) }
end

#
# extract the [key]=[value] pair from the @argv
# 
def options
    @argv.select {|a| /^.+[\=]+.+$/ =~ a }
end

def dry_run?
    @argv.select {|a| a == "-d" }.first
end

def localhost?
    @argv.include?("-l")
end

#
# extract the api optcode from the @argv
#
def api 
    api = @argv.select {|a| APIS.include?(a.strip) }
    unless api.size > 0
        puts "\napi missing. please input any of the following:\n\n"
        APIS.each {|a| puts a}
        puts
        abort
    end
    api.first
end

def translate_customer
    {
        delete:    "destroy_a_customer",
        create_wc: "create_a_customer_and_attach_a_card",
        create:    "create_a_customer",
        add_card:  "attach_a_card_to_customer",
        list:      "list_all_customers",
        list_all:  "list_all_customers",
        get:       "retrieve_a_customer",
        update:    "update_a_customer",
    }
end

def translate_token
    {
        create: "create_a_token", 
        get:    "retrieve_a_token",
    }
end

def translate_card
    {
        delete:   "destroy_a_card",
        list:     "list_all_cards",
        list_all: "list_all_cards",
        get:      "retrieve_a_card",
        update:   "update_a_card",
    }
end

def translate_charge
    {
        list:     "list_all_charges",
        list_all: "list_all_charges",
        update:   "update_a_charge", 
        reverse:  "reverse_an_uncaptured_charge",
        get:      "retrieve_a_charge",
        coib:     "create_an_offsite_internet_banking_charge",
        coa:      "create_an_offsite_alipay_charge",
        wt:       "charge_a_card_using_a_token",
        wcc:      "charge_a_card_using_a_customer_and_a_card",
        wc:       "charge_a_card_using_a_customer",
        capture:  "capture_an_authorized_charge",
    }
end

def translate_dispute
    {
        list:     "list_all_disputes",
        list_all: "list_all_disputes",
        lao:      "list_all_open_disputes",
        lap:      "list_all_pending_disputes",
        lac:      "list_all_closed_disputes",
        get:      "retrieve_a_dispute",
        update:   "update_a_dispute",
    }
end

def translate_recipient
    {
        list:    "list_all_recipient",
        create:  "create_a_recipient",
        get:     "retrieve_a_recipient",
        update:  "update_a_recipient",
        delete:  "destroy_a_recipient" 
    }
end

def translate_refund
    {
        list:     "list_all_refunds",
        list_all: "list_all_refunds",
        lap:      "list_all_refunds_of_particular_charge",
        get:      "retrieve_a_refund",
        create:   "create_a_refund",
    }
end

def translate_transfer
    {
        create:   "create_a_transfer",
        cr3:      "create_a_transfer_to_third_party_recipient",
        delete:   "destroy_a_transfer",
        list:     "list_all_transfers",
        get:      "retrieve_a_transfer",
        update:   "update_a_transfer",
    }
end

#
# Mapping function such as:
#
# [api_identifier] -> /[api_identifier]/[api_file_name under the script repository]
#
def translate(api, key)
    api_translation = {
        charge:    translate_charge,
        card:      translate_card,
        customer:  translate_customer,
        token:     translate_token,
        dispute:   translate_dispute,
        refund:    translate_refund,
        recipient: translate_recipient,
        transfer:  translate_transfer
    }[api.to_sym]
    abort "api missing" unless api_translation 
    result = api_translation[(key || "").to_sym]
    help(api) unless result
    result
end

def lang
    languages = %w(ruby python java)
    languages.each do |l|
        if @argv.include?(l)
            return l
        end
    end
    nil
end

def get_script_path(key, language, psp)
    psp      ||= "omise"
    language ||= "curl"
    script_path = "#{SCRIPTS}/#{language}/#{api}/#{translate(api, key)}"
    unless File.exist?(script_path)
        abort("\nscript_path #{script_path} does not exist\n\n")
    end
    script_path
end

def verbs
    @argv.select do |a|
        %w(
            create
            delete
            create_wc
            add_card
            list
            get
            update
            coib
            coa
            wcc
            wc
            capture
            reverse
        ).include?(a)
    end.first    
end

script_path = get_script_path(verbs, lang, @psp)
script_body = File.read(script_path)
                  .gsub("$skey", skey)
                  .gsub("$pkey", pkey)

#
# gsub the $[key] parameter in script file 
# into the value of @argv option [key]=[value]
#
def gsub(key, script_body, options, config)
    if script_body.include?("$#{key}")
        if options[key]
            script_body = script_body.gsub("$#{key}", options[key])  
        elsif config[key]    
            script_body = script_body.gsub("$#{key}", config[key])  
        else
            abort "You need argument #{key}="
        end
    end
    script_body
end        

def api_root
    root = {
        omise:  "api.omise.co",
        stripe: "api.stripe.com/v1"
    }[@psp.to_sym]
    abort("api root missing") unless root
    root  
end

def host
    localhost? ? "http://api.lvh.me:3000" : "https://#{api_root}"
end

#
# XXX LITTLE BIT VERBOSE, NEEDS OPTIMIZATION HERE
#
def update_url_in_script_body(script, new_url)
    if @psp == "omise"
        subdomain = api.start_with?("token") ? "vault" : "api"
        script = script.gsub("https://#{subdomain}.omise.co", new_url)
        if api.start_with?("token")  
            script = script.gsub("api.lvh.me:3000", "vault.lvh.me:4500")
        end  
    end    
    script
end

def secondary_api_call(script_body, skey, api, prefix, value)
    puts
    if api == "card"
        puts api
        cmd = "curl -s -X GET #{host}/customers/#{value}/cards -u #{skey}"
    else    
        cmd = "curl -s -X GET #{host}/#{api}s -u #{skey}"
    end
    puts "[Secondary Command Call]: #{cmd.cyan}"
    result = `#{cmd}`
    if result.include?("authentication failed")
        abort("\n\nauthentication failure: #{cmd}\n\n")
    end
    result
        .split("\n")
        .select { |a| a.include?(prefix) }
        .map    { |a| /#{prefix}[a-z0-9_]+/.match(a).to_s.strip }
        .uniq
end

#
# XXX needs to be refactored
#
# if specific parameter is missing, this script enlist the
# existing values, then, let user choose the one,
# and eventually this value is assigned to the main script_body
#
def list_values_and_gsub(script_body, skey, api, prefix, options, value="")
    if script_body.include?("$#{api}") 
        list = secondary_api_call(script_body, skey, api, prefix, value)
        if api == "customer" && options["customer"]
            value = options["customer"]
        else
            if list.size == 0
                abort("[#{api}]:               No record")
            elsif list.size == 1    
                value = list[0]
            else  
                list.each_with_index { |e, i| puts "[#{i}] #{e}" }
                print "\n[which?][q:Quit] "    
                input = $stdin.gets.chomp
                abort if input.downcase == "q"
                value = list[input.to_i]
            end
        end    
        script_body = script_body.gsub("$#{api}", value)
    end
    [script_body, value]
end

#
# XXX need this to be refactored as iteration
#
script_body = gsub("transfer", script_body, options, config_hash)
script_body = gsub("recipient", script_body, options, config_hash)
script_body = gsub("charge", script_body, options, config_hash)
script_body = gsub("token", script_body, options, config_hash)
script_body = gsub("dispute", script_body, options, config_hash)
script_body = gsub("amount", script_body, options, config_hash)
script_body, value = list_values_and_gsub(script_body, skey, "customer", "cust_", options)
script_body, value = list_values_and_gsub(script_body, skey, "charge", "chrg_", options, value)
script_body, value = list_values_and_gsub(script_body, skey, "card", "card_", options, value)

#
# script_body update
#
if localhost?
    script_body = update_url_in_script_body(script_body, "http://api.lvh.me:3000")
end  

unless script_path.include?("curl -s")
    script_body = script_body.gsub("curl", "curl -s")
end

def pre_edit?
    @argv.include?("-e")
end

#
# if the argument "-e" included in @argv,
# command can be edited with vim editor before its execution.
#
if pre_edit?
    tmp = ".tmp_file_omise"
    File.open(tmp, "w") { |f| f.puts script_body }
    system("vim #{tmp}")
    script_body = File.read(tmp)
    system("rm #{tmp}")
end

unless /curl\s+\-s/ =~ script_body
    script_body = script_body.gsub("curl", "curl -s")
end

def pre_edit?
    @argv.include?("-e")
end

#
# remove commented lines from the script file
#
command = script_body.lines.select { |line| !(line.start_with?("#")) }.join.chomp

if dry_run?
   result_file_name = "curl_result.tmp"
   if vim?
       File.open(result_file_name, "w") do |f|
           f.puts script_body
       end
       system "vim #{result_file_name}"
   else
       puts script_body
   end  
   abort  
end

#
# remove -s from curl
#
if @argv.include?("--rms")
  script_body = script_body.gsub("-s", "") 
  command     = command.gsub("-s", "")
end

def print_tmp_file(sentence)
   result_file_name = "curl_result.tmp"
   File.open(result_file_name, "w") do |f|
       f.puts sentence
   end
   result_file_name
end

@lang = lang

def get_detail
    {
      ruby: ["rb", "gem install omise"]
    }[@lang&.to_sym] || abort("language not supported")
end

if @lang
    detail = get_detail
else
    @lang = "curl"
end    

def exec(command, detail)
    if @lang == "curl"
        shell_execution_result = `#{command}`
    else
        tmp_exe = "tmp.#{detail[0]}"
        system "#{detail[1]}"
        File.open(tmp_exe, "w") { |f| f.puts command }
        shell_execution_result = `ruby #{tmp_exe}`
        system "rm #{tmp_exe}"
    end
    shell_execution_result
end

#
# this is the __main__ execution part
#
if vim?
    # result   = `#{script_body}`
    result = exec(command, detail)
    sentence = "#{script_body.strip}\n\n#{result}"
    result_file_name = print_tmp_file(sentence)
    system "vim #{result_file_name}"
else
    shell_execution_result = exec(command, detail)
    puts "-------------------------"
    puts "[Command]\n"
    puts command.green
    puts "-------------------------"

    puts "[Result]"

    if shell_execution_result.include?("<div")
        print_tmp_file(shell_execution_result)
        system "open result.html"
        abort
    else
        if shell_execution_result.include?("\"security_code_check\": false")
            puts shell_execution_result.gsub(/("security_code_check"\:\sfalse)/, "\\1".red)
            puts "[charge failed]".red
        else
            puts shell_execution_result
        end    
        if shell_execution_result.include?("authentication_failure")
            puts "is your skey/pkey really correct?".red
        end
    end

    if File.basename(script_path) == "create_a_token"
        token = shell_execution_result
            .split("\n")
            .select{ |a| a.include?("tokn_")             }
            .map   { |a| /tokn_[a-z0-9_]+/.match(a).to_s }
            .flatten
            .uniq
        `echo token=#{token.first} | pbcopy`    
    end
end    
